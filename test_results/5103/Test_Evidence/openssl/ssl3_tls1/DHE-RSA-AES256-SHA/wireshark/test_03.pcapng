1)
				badarg = 1;
			else
				outfile= *(++argv);
		} else if(!strcmp(*argv, "-inkey")) {
			if (--argc < 1)
				badarg = 1;
			else
				keyfile = *(++argv);
		} else if (!strcmp(*argv,"-passin")) {
			if (--argc < 1)
				badarg = 1;
			else
				passargin= *(++argv);
		} else if (strcmp(*argv,"-keyform") == 0) {
			if (--argc < 1)
				badarg = 1;
			else
				keyform=str2fmt(*(++argv));
#ifndef OPENSSL_NO_ENGINE
		} else if(!strcmp(*argv, "-engine")) {
			if (--argc < 1)
				badarg = 1;
			else
				engine = *(++argv);
#endif
		} else if(!strcmp(*argv, "-pubin")) {
			key_type = KEY_PUBKEY;
		} else if(!strcmp(*argv, "-certin")) {
			key_type = KEY_CERT;
		} 
		else if(!strcmp(*argv, "-asn1parse")) asn1parse = 1;
		else if(!strcmp(*argv, "-hexdump")) hexdump = 1;
		else if(!strcmp(*argv, "-raw")) pad = RSA_NO_PADDING;
		else if(!strcmp(*argv, "-oaep")) pad = RSA_PKCS1_OAEP_PADDING;
		else if(!strcmp(*argv, "-ssl")) pad = RSA_SSLV23_PADDING;
		else if(!strcmp(*argv, "-pkcs")) pad = RSA_PKCS1_PADDING;
		else if(!strcmp(*argv, "-x931")) pad = RSA_X931_PADDING;
		else if(!strcmp(*argv, "-sign")) {
			rsa_mode = RSA_SIGN;
			need_priv = 1;
		} else if(!strcmp(*argv, "-verify")) rsa_mode = RSA_VERIFY;
		else if(!strcmp(*argv, "-rev")) rev = 1;
		else if(!strcmp(*argv, "-encrypt")) rsa_mode = RSA_ENCRYPT;
		else if(!strcmp(*argv, "-decrypt")) {
			rsa_mode = RSA_DECRYPT;
			need_priv = 1;
		} else badarg = 1;
		if(badarg) {
			usage();
			goto end;
		}
		argc--;
		argv++;
	}

	if(need_priv && (key_type != KEY_PRIVKEY)) {
		BIO_printf(bio_err, "A private key is needed for this operation\n");
		goto end;
	}

#ifndef OPENSSL_NO_ENGINE
        e = setup_engine(bio_err, engine, 0);
#endif
	if(!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}

/* FIXME: seed PRNG only if needed */
	app_RAND_load_file(NULL, bio_err, 0);
	
	switch(key_type) {
		case KEY_PRIVKEY:
		pkey = load_key(bio_err, keyfile, keyform, 0,
			passin, e, "Private Key");
		break;

		case KEY_PUBKEY:
		pkey = load_pubkey(bio_err, keyfile, keyform, 0,
			NULL, e, "Public Key");
		break;

		case KEY_CERT:
		x = load_cert(bio_err, keyfile, keyform,
			NULL, e, "Certificate");
		if(x) {
			pkey = X509_get_pubkey(x);
			X509_free(x);
		}
		break;
	}

	if(!pkey) {
		return 1;
	}

	rsa = EVP_PKEY_get1_RSA(pkey);
	EVP_PKEY_free(pkey);

	if(!rsa) {
		BIO_printf(bio_err, "Error getting RSA key\n");
		ERR_print_errors(bio_err);
		goto end;
	}


	if(infile) {
		if(!(in = BIO_new_file(infile, "rb"))) {
			BIO_printf(bio_err, "Error Reading Input File\n");
			ERR_print_errors(bio_err);	
			goto end;
		}
	} else in = BIO_new_fp(stdin, BIO_NOCLOSE);

	if(outfile) {
		if(!(out = BIO_new_file(outfile, "wb"))) {
			BIO_printf(bio_err, "Error Reading Output File\n");
			ERR_print_errors(bio_err);	
			goto end;
		}
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
#ifdef OPENSSL_SYS_VMS
		{
		    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		    out = BIO_push(tmpbio, out);
		}
#endif
	}

	keysize = RSA_size(rsa);

	rsa_in = OPENSSL_malloc(keysize * 2);
	rsa_out = OPENSSL_malloc(keysize);

	/* Read the input data */
	rsa_inlen = BIO_read(in, rsa_in, keysize * 2);
	if(rsa_inlen <= 0) {
		BIO_printf(bio_err, "Error reading input Data\n");
		exit(1);
	}
	if(rev) {
		int i;
		unsigned c