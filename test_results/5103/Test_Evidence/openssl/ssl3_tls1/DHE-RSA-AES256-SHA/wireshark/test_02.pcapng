ere options are\n");
#ifndef OPENSSL_NO_DES
		BIO_printf(bio_err, "-crypt             standard Unix password algorithm (default)\n");
#endif
#ifndef NO_MD5CRYPT_1
		BIO_printf(bio_err, "-1                 MD5-based password algorithm\n");
		BIO_printf(bio_err, "-apr1              MD5-based password algorithm, Apache variant\n");
#endif
		BIO_printf(bio_err, "-salt string       use provided salt\n");
		BIO_printf(bio_err, "-in file           read passwords from file\n");
		BIO_printf(bio_err, "-stdin             read passwords from stdin\n");
		BIO_printf(bio_err, "-noverify          never verify when reading password from terminal\n");
		BIO_printf(bio_err, "-quiet             no warnings\n");
		BIO_printf(bio_err, "-table             format output as table\n");
		BIO_printf(bio_err, "-reverse           switch table columns\n");
		
		goto err;
		}

	if ((infile != NULL) || in_stdin)
		{
		in = BIO_new(BIO_s_file());
		if (in == NULL)
			goto err;
		if (infile != NULL)
			{
			assert(in_stdin == 0);
			if (BIO_read_filename(in, infile) <= 0)
				goto err;
			}
		else
			{
			assert(in_stdin);
			BIO_set_fp(in, stdin, BIO_NOCLOSE);
			}
		}
	
	if (usecrypt)
		pw_maxlen = 8;
	else if (use1 || useapr1)
		pw_maxlen = 256; /* arbitrary limit, should be enough for most passwords */

	if (passwds == NULL)
		{
		/* no passwords on the command line */

		passwd_malloc_size = pw_maxlen + 2;
		/* longer than necessary so that we can warn about truncation */
		passwd = passwd_malloc = OPENSSL_malloc(passwd_malloc_size);
		if (passwd_malloc == NULL)
			goto err;
		}

	if ((in == NULL) && (passwds == NULL))
		{
		/* build a null-terminated list */
		static char *passwds_static[2] = {NULL, NULL};
		
		passwds = passwds_static;
		if (in == NULL)
			if (EVP_read_pw_string(passwd_malloc, passwd_malloc_size, "Password: ", !(passed_salt || in_noverify)) != 0)
				goto err;
		passwds[0] = passwd_malloc;
		}

	if (in == NULL)
		{
		assert(passwds != NULL);
		assert(*passwds != NULL);
		
		do /* loop over list of passwords */
			{
			passwd = *passwds++;
			if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,
				quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
				goto err;
			}
		while (*passwds != NULL);
		}
	else
		/* in != NULL */
		{
		int done;

		assert (passwd != NULL);
		do
			{
			int r = BIO_gets(in, passwd, pw_maxlen + 1);
			if (r > 0)
				{
				char *c = (strchr(passwd, '\n')) ;
				if (c != NULL)
					*c = 0; /* truncate at newline */
				else
					{
					/* ignore rest of line */
					char trash[BUFSIZ];
					do
						r = BIO_gets(in, trash, sizeof trash);
					while ((r > 0) && (!strchr(trash, '\n')));
					}
				
				if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,
					quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
					goto err;
				}
			done = (r <= 0);
			}
		while (!done);
		}
	ret = 0;

err:
	ERR_print_errors(bio_err);
	if (salt_malloc)
		OPENSSL_free(salt_malloc);
	if (passwd_malloc)
		OPENSSL_free(passwd_malloc);
	if (in)
		BIO_free(in);
	if (out)
		BIO_free_all(out);
	apps_shutdown();
	OPENSSL_EXIT(ret);
	}


#ifndef NO_MD5CRYPT_1
/* MD5-based password algorithm (should probably be available as a library
 * function; then the static buffer would not be acceptable).
 * For magic string "1", this should be compatible to the MD5-based BSD
 * password algorithm.
 * For 'mag