point)
* to be displayed in a formatted monetary quantity.
* .iP "char p_cs_precedes"
* Set to 1 or 0 if the `currency_symbol' respectively precedes or
* succeeds the value for a nonnegative formatted monetary quantity.
* .iP "char p_sep_by_space"
* Set to 1 or 0 if the `currency_symbol' respectively is or is not
* separated by a space from the value for a nonnegative formatted
* monetary quantity.
* .iP "char n_cs_precedes"
* Set to 1 or 0 if the `currency_symbol' respectively precedes or
* succeeds the value for a negative formatted monetary quantity.
* .iP "char n_sep_by_space"
* Set to 1 or 0 if the `currency_symbol' respectively is or is not
* separated by a space from the value for a negative formatted monetary
* quantity.
* .iP "char p_sign_posn"
* Set to a value indicating the positioning of the `positive_sign'
* for a nonnegative formatted monetary quantity.
* .iP "char n_sign_posn"
* Set to a value indicating the positioning of the `negative_sign'
* for a negative formatted monetary quantity.
*
* .LP
* The elements of `grouping' and `mon_grouping' are interpreted according
* to the following:
* .iP "CHAR_MAX" "" 1
* No further grouping is to be performed.
* .iP "0"
* The previous element is to be repeatedly used for the remainder of the digits.
* .iP "other"
* The integer value is the number of the digits that comprise the current
* group.  The next element is examined to determined the size of the next
* group of digits before the current group.
*
* .LP
* The values of `p_sign_posn' and `n_sign_posn' are interpreted according to
* the following:
* .iP "0"
* Parentheses surround the quantity and `currency_symbol'.
* .iP "1"
* The sign string precedes the quantity and `currency_symbol'.
* .iP "2"
* The sign string succeeds the quantity and `currency_symbol'.
* .iP "3"
* The sign string immediately precedes the `currency_symbol'.
* .iP "4"
* The sign string immediately succeeds the `currency_symbol'.
*
* .LP
* The implementation behaves as if no library function calls localeconv().
*
* The localeconv() routine returns a pointer to the filled-in object.  The
* structure pointed to by the return value is not modified by the
* program, but may be overwritten by a subsequent call to localeconv().
* In addition, calls to setlocale() with categories LC_ALL, LC_MONETARY,
* or LC_NUMERIC may overwrite the contents of the structure.
*
* INCLUDE FILES: locale.h, limits.h
*
* RETURNS: A pointer to the structure `lconv'.
*/

struct lconv *localeconv (void)
    {
    return (&__locale);
    }


/* setlocale.c - ANSI locale */

/* Copyright 1992-1993 Wind River Systems, Inc. */

/*
modification history
--------------------
01f,30aug93,jmm  fixed null pointer dereference in setlocale() (spr 2490)
01e,07feb93,jdi  documentation cleanup for 5.1.
01d,28sep92,smb  added ANSI to function description
01c,20sep92,smb  documentation additions
01b,14sep92,smb  added some minor error checking.
01a,08jul92,smb  written
*/

/*
DESCRIPTION

INCLUDE FILE: locale.h string.h stdlib.h 

SEE ALSO: American National Standard X3.159-1989

NOMANUAL
*/

#include "vxWorks.h"
#include "locale.h"
#include "string.h"
#include "stdlib.h"
#include "ctype.h"
#include "private/localeP.h"

LOCAL char *currentName = "C";		/* current locale name */
__linfo	    __clocale = 
    {
    "C"
    };


/*******************************************************************************
*
* setlocale - set the appropriate locale (ANSI)
*
* This function is included for ANSI compatibility.  Only the default is
* implemented.  At program start-up, the equivalent of the following is
* execute