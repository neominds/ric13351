=pod

=head1 NAME

lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error - dynamic hash table

=head1 SYNOPSIS

 #include <openssl/lhash.h>

 LHASH *lh_new(LHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE compare);
 void lh_free(LHASH *table);

 void *lh_insert(LHASH *table, void *data);
 void *lh_delete(LHASH *table, void *data);
 void *lh_retrieve(LHASH *table, void *data);

 void lh_doall(LHASH *table, LHASH_DOALL_FN_TYPE func);
 void lh_doall_arg(LHASH *table, LHASH_DOALL_ARG_FN_TYPE func,
          void *arg);

 int lh_error(LHASH *table);

 typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
 typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);

=head1 DESCRIPTION

This library implements dynamic hash tables. The hash table entries
can be arbitrary structures. Usually they consist of key and value
fields.

lh_new() creates a new B<LHASH> structure to store arbitrary data
entries, and provides the 'hash' and 'compare' callbacks to be used in
organising the table's entries.  The B<hash> callback takes a pointer
to a table entry as its argument and returns an unsigned long hash
value for its key field.  The hash value is normally truncated to a
power of 2, so make sure that your hash function returns well mixed
low order bits.  The B<compare> callback takes two arguments (pointers
to two hash table entries), and returns 0 if their keys are equal,
non-zero otherwise.  If your hash table will contain items of some
particular type and the B<hash> and B<compare> callbacks hash/compare
these types, then the B<DECLARE_LHASH_HASH_FN> and
B<IMPLEMENT_LHASH_COMP_FN> macros can be used to create callback
wrappers of the prototypes required by lh_new().  These provide
per-variable casts before calling the type-specific callbacks written
by the application author.  These macros, as well as those used for
the "doall" callbacks, are defined as;

 #define DECLARE_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *arg) { \
                 o_type a = (o_type)arg; \
                 return f_name(a); }
 #define LHASH_HASH_FN(f_name) f_name##_LHASH_HASH

 #define DECLARE_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 o_type b = (o_type)arg2; \
                 return f_name(a,b); }
 #define LHASH_COMP_FN(f_name) f_name##_LHASH_COMP

 #define DECLARE_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *);
 #define IMPLEMENT_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *arg) { \
                 o_type a = (o_type)arg; \
                 f_name(a); }
 #define LHASH_DOALL_FN(f_name) f_name##_LHASH_DOALL

 #define DECLARE_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *, const void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 a_type b = (a_type)arg2; \
                 f_name(a,b); }
 #define LHASH_DOALL_ARG_FN(f_name) f_name##_LHASH_DOALL_ARG

An example of a hash table stori